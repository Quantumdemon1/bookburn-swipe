-- Drop existing tables if they exist
drop table if exists public.messages cascade;
drop table if exists public.conversation_participants cascade;
drop table if exists public.conversations cascade;
drop table if exists public.cart_items cascade;
drop table if exists public.book_interactions cascade;
drop table if exists public.reactions cascade;
drop table if exists public.comments cascade;
drop table if exists public.reviews cascade;
drop table if exists public.user_preferences cascade;
drop table if exists public.profiles cascade;
drop table if exists public.books cascade;

-- Create tables first
create table public.books (
  id bigint generated by default as identity primary key,
  title text not null,
  author text not null,
  price numeric(10,2) not null,
  tags text[] not null default '{}',
  preview text not null,
  cover_url text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  name text,
  avatar_url text,
  bio text,
  is_verified boolean default false,
  member_number integer,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.reviews (
  id bigint generated by default as identity primary key,
  book_id bigint references public.books(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade not null,
  content text not null,
  rating integer not null check (rating >= 1 and rating <= 5),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.comments (
  id bigint generated by default as identity primary key,
  review_id bigint references public.reviews(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade not null,
  content text not null,
  parent_id bigint references public.comments(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.user_preferences (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null unique,
  preferences jsonb not null default '{}',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.reactions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  review_id bigint references public.reviews(id) on delete cascade,
  comment_id bigint references public.comments(id) on delete cascade,
  type text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  constraint reactions_target_check check (
    (review_id is not null and comment_id is null) or
    (review_id is null and comment_id is not null)
  )
);

create table public.book_interactions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  book_id bigint references public.books(id) on delete cascade not null,
  action text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.cart_items (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  book_id bigint references public.books(id) on delete cascade not null,
  quantity integer not null check (quantity > 0),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, book_id)
);

create table public.conversations (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table public.conversation_participants (
  conversation_id bigint references public.conversations(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (conversation_id, user_id)
);

create table public.messages (
  id bigint generated by default as identity primary key,
  conversation_id bigint references public.conversations(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade not null,
  content text not null,
  is_read boolean default false not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Drop existing function if it exists
drop function if exists public.handle_updated_at() cascade;

-- Create functions for triggers
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Create triggers
create trigger handle_books_updated_at
  before update on public.books
  for each row
  execute function public.handle_updated_at();

create trigger handle_profiles_updated_at
  before update on public.profiles
  for each row
  execute function public.handle_updated_at();

create trigger handle_reviews_updated_at
  before update on public.reviews
  for each row
  execute function public.handle_updated_at();

create trigger handle_comments_updated_at
  before update on public.comments
  for each row
  execute function public.handle_updated_at();

create trigger handle_user_preferences_updated_at
  before update on public.user_preferences
  for each row
  execute function public.handle_updated_at();

create trigger handle_cart_items_updated_at
  before update on public.cart_items
  for each row
  execute function public.handle_updated_at();

create trigger handle_conversations_updated_at
  before update on public.conversations
  for each row
  execute function public.handle_updated_at();

create trigger handle_messages_updated_at
  before update on public.messages
  for each row
  execute function public.handle_updated_at();

-- Enable RLS
alter table public.books enable row level security;
alter table public.profiles enable row level security;
alter table public.reviews enable row level security;
alter table public.comments enable row level security;
alter table public.user_preferences enable row level security;
alter table public.reactions enable row level security;
alter table public.book_interactions enable row level security;
alter table public.cart_items enable row level security;
alter table public.conversations enable row level security;
alter table public.conversation_participants enable row level security;
alter table public.messages enable row level security;

-- Create policies
create policy "Public books are viewable by everyone"
  on public.books for select
  using (true);

create policy "Users can view their own profile"
  on public.profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on public.profiles for update
  using (auth.uid() = id);

create policy "Reviews are viewable by everyone"
  on public.reviews for select
  using (true);

create policy "Users can create reviews"
  on public.reviews for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own reviews"
  on public.reviews for update
  using (auth.uid() = user_id);

create policy "Comments are viewable by everyone"
  on public.comments for select
  using (true);

create policy "Users can create comments"
  on public.comments for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own comments"
  on public.comments for update
  using (auth.uid() = user_id);

create policy "Users can manage their own preferences"
  on public.user_preferences for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can manage their reactions"
  on public.reactions for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can manage their book interactions"
  on public.book_interactions for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can manage their cart items"
  on public.cart_items for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can view their conversations"
  on public.conversations for select
  using (exists (
    select 1 from public.conversation_participants
    where conversation_id = id
    and user_id = auth.uid()
  ));

create policy "Users can view conversation participants"
  on public.conversation_participants for select
  using (user_id = auth.uid() or exists (
    select 1 from public.conversation_participants
    where conversation_id = conversation_participants.conversation_id
    and user_id = auth.uid()
  ));

create policy "Users can view their messages"
  on public.messages for select
  using (exists (
    select 1 from public.conversation_participants
    where conversation_id = messages.conversation_id
    and user_id = auth.uid()
  ));

create policy "Users can send messages"
  on public.messages for insert
  with check (exists (
    select 1 from public.conversation_participants
    where conversation_id = messages.conversation_id
    and user_id = auth.uid()
  ));

-- Create indexes for better performance
create index reactions_user_id_idx on public.reactions(user_id);
create index reactions_review_id_idx on public.reactions(review_id);
create index reactions_comment_id_idx on public.reactions(comment_id);
create index book_interactions_user_id_idx on public.book_interactions(user_id);
create index book_interactions_book_id_idx on public.book_interactions(book_id);
create index messages_conversation_id_idx on public.messages(conversation_id);
create index messages_user_id_idx on public.messages(user_id);