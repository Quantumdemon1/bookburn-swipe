-- Create additional tables for the application

-- Create profiles table if it doesn't exist
create table if not exists public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  name text,
  avatar_url text,
  bio text,
  is_verified boolean default false,
  member_number integer,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create reactions table if it doesn't exist
create table if not exists public.reactions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  review_id bigint references public.reviews(id) on delete cascade,
  comment_id bigint references public.comments(id) on delete cascade,
  type text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  constraint reactions_target_check check (
    (review_id is not null and comment_id is null) or
    (review_id is null and comment_id is not null)
  )
);

-- Create book interactions table if it doesn't exist
create table if not exists public.book_interactions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  book_id bigint references public.books(id) on delete cascade not null,
  action text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create cart items table if it doesn't exist
create table if not exists public.cart_items (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  book_id bigint references public.books(id) on delete cascade not null,
  quantity integer not null check (quantity > 0),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, book_id)
);

-- Create conversations table if it doesn't exist
create table if not exists public.conversations (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create conversation participants table if it doesn't exist
create table if not exists public.conversation_participants (
  conversation_id bigint references public.conversations(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (conversation_id, user_id)
);

-- Create messages table if it doesn't exist
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  conversation_id bigint references public.conversations(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade not null,
  content text not null,
  is_read boolean default false not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create triggers for updated_at if they don't exist
do $$ 
begin
  if not exists (select 1 from pg_trigger where tgname = 'handle_profiles_updated_at') then
    create trigger handle_profiles_updated_at
      before update on public.profiles
      for each row
      execute function public.handle_updated_at();
  end if;

  if not exists (select 1 from pg_trigger where tgname = 'handle_cart_items_updated_at') then
    create trigger handle_cart_items_updated_at
      before update on public.cart_items
      for each row
      execute function public.handle_updated_at();
  end if;

  if not exists (select 1 from pg_trigger where tgname = 'handle_conversations_updated_at') then
    create trigger handle_conversations_updated_at
      before update on public.conversations
      for each row
      execute function public.handle_updated_at();
  end if;

  if not exists (select 1 from pg_trigger where tgname = 'handle_messages_updated_at') then
    create trigger handle_messages_updated_at
      before update on public.messages
      for each row
      execute function public.handle_updated_at();
  end if;
end $$;

-- Enable RLS
alter table public.profiles enable row level security;
alter table public.reactions enable row level security;
alter table public.book_interactions enable row level security;
alter table public.cart_items enable row level security;
alter table public.conversations enable row level security;
alter table public.conversation_participants enable row level security;
alter table public.messages enable row level security;

-- Create RLS policies (dropping existing ones first to avoid conflicts)
drop policy if exists "Users can view their own profile" on public.profiles;
drop policy if exists "Users can update their own profile" on public.profiles;
drop policy if exists "Users can manage their reactions" on public.reactions;
drop policy if exists "Users can manage their book interactions" on public.book_interactions;
drop policy if exists "Users can manage their cart items" on public.cart_items;
drop policy if exists "Users can view their conversations" on public.conversations;
drop policy if exists "Users can view conversation participants" on public.conversation_participants;
drop policy if exists "Users can view their messages" on public.messages;
drop policy if exists "Users can send messages" on public.messages;

create policy "Users can view their own profile"
  on public.profiles for select
  using (auth.uid() = id);

create policy "Users can update their own profile"
  on public.profiles for update
  using (auth.uid() = id);

create policy "Users can manage their reactions"
  on public.reactions for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can manage their book interactions"
  on public.book_interactions for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can manage their cart items"
  on public.cart_items for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users can view their conversations"
  on public.conversations for select
  using (exists (
    select 1 from public.conversation_participants
    where conversation_id = id
    and user_id = auth.uid()
  ));

create policy "Users can view conversation participants"
  on public.conversation_participants for select
  using (user_id = auth.uid() or exists (
    select 1 from public.conversation_participants
    where conversation_id = conversation_participants.conversation_id
    and user_id = auth.uid()
  ));

create policy "Users can view their messages"
  on public.messages for select
  using (exists (
    select 1 from public.conversation_participants
    where conversation_id = messages.conversation_id
    and user_id = auth.uid()
  ));

create policy "Users can send messages"
  on public.messages for insert
  with check (exists (
    select 1 from public.conversation_participants
    where conversation_id = messages.conversation_id
    and user_id = auth.uid()
  ));

-- Create indexes for better performance
create index if not exists reactions_user_id_idx on public.reactions(user_id);
create index if not exists reactions_review_id_idx on public.reactions(review_id);
create index if not exists reactions_comment_id_idx on public.reactions(comment_id);
create index if not exists book_interactions_user_id_idx on public.book_interactions(user_id);
create index if not exists book_interactions_book_id_idx on public.book_interactions(book_id);
create index if not exists messages_conversation_id_idx on public.messages(conversation_id);
create index if not exists messages_user_id_idx on public.messages(user_id);